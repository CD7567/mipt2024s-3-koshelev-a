# Task 2: JSON Parser

## Преамбула

Тестовые датасеты из репозитория: [willcrichton/corrset-benchmark](https://github.com/willcrichton/corrset-benchmark)

Структура JSON (в файле хранится без space символов):

```json
[
  {"user":"32121608-5d1b-4bda-9ff8-323afe47c0ed","question":"80c01e0f-a88d-48f6-a879-795d14b92d3e","score":0},
  {"user":"c6ef79b6-dff8-49c5-b4f2-51d07d206e98","question":"80c01e0f-a88d-48f6-a879-795d14b92d3e","score":0},
  {"user":"7a241e06-be79-4a77-b67c-883d6c017f18","question":"80c01e0f-a88d-48f6-a879-795d14b92d3e","score":1},
  {"user":"098132c1-deb8-448b-92c0-e8eba26b31e4","question":"80c01e0f-a88d-48f6-a879-795d14b92d3e","score":0},
  {"user":"80a35735-43fd-4a41-8f33-8bb798943f08","question":"80c01e0f-a88d-48f6-a879-795d14b92d3e","score":0}
]
```

## Описание решения

Реализованы два класса:

- `StreamParser` читает данные напрямую из файлового потока
- `FullreadParser` читает данныые целиком в память, затем сдвигами получает данные

Запись данных может быть отключена выставлением флага компиляции `-DDO_JSON_SKIP_WRITING=ON`.

## Анализ решения

Заранее можно предсказать, что написанные под конкретную структуру парсеры будут быстрее общего случая (библиотека `nlohmann::json`). Помимо этого, отключение фактической экстракции данных должно ускорить кастомные парсеры и SAX-режим библиотеки, так как можно отключить сохранение ивентов.

Получены следующие данные (время замерено в миллисекундах):

### data-small.json

|  mode | DOM| SAX|Stream|Fullread|
|-------|----|----|------|--------|
| write |42.0|38.0| 11.0 |   3.0  |
|nowrite|47.0|33.0|  6.0 |   2.0  |

### data-medium.json

|  mode | DOM | SAX |Stream|Fullread|
|-------|-----|-----|------|--------|
| write |406.5|391.0| 113.0|  43.5  |
|nowrite|418.0|285.0| 72.5 |  41.5  |

Видно относительное постоянство времени DOM-режима, ускорение SAX-режима библиотеки, как это было предсказано ранее. Для кастомных парсеров `Stream` версия ускоряется значительно из-за посимвольного чтения и копирования данных в структуры. Однако `Fullread` версия ускорение почти не получает, поскольку копирование происходит внутри памяти, что значительно быстрее.
